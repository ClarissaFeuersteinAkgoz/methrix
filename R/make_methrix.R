#' Generates methrix from bismark coverage files
#' @details Reads bismark coverage files and generates methylation and coverage matrices. Optionally arrays can be serialized as on-disk HDFS5 arrays.
#' @param files bedgraphs or coverage files generated by Bismark. Default NULL
#' @param loci NULL (Default) or a file with  "chromsome" and "start" position. If provided matrix will be generated for these CpGs
#' @param colData An optional DataFrame describing the samples. Row names, if present, become the column names of the matrix. If NULL, then a DataFrame will be created with basename of files used as the row names.
#' @param file_format are input files bedgraph or coverage files. Default 'auto' predicts.
#' @param vectorize Default TRUE. If FALSE uses for loop (much slower but consumes lesser memory)
#' @param n_cores number of cores to use. Default NULL. Uses available cores - 1
#' @param shift_start Default FALSE. If coordinates are one-based, set this is to TRUE, and start positions will be shifted to its previous base (0-based).
#' @param h5 Should the coverage and methylation matrices be stored as "HDF5Array"
#' @param h5_dir directory to store H5 based object
#' @export
#' @import data.table
#' @import parallel
#' @import SummarizedExperiment

read_bismark = function(files = NULL, colData = NULL, file_format = "auto",
                                loci = NULL, vectorize = TRUE,
                                n_cores = NULL, shift_start = FALSE, h5 = FALSE, h5_dir = NULL){

  #Check file-types (could be bedgraphs or coverage)
  if(file_format == "auto"){
    message("#-Guessing file types..")
    bedgraphs_filetypes = unlist(lapply(files, .guess_bismark_file_type), use.names = TRUE)
    message("File types recognized:")
    print(table(bedgraphs_filetypes, exclude = NULL))

    unknw_filetypes = which(is.na(bedgraphs_filetypes))
    if(length(unknw_filetypes) > 0 ){
      stop(paste0("Ignoring ", length(unknw_filetypes), " file(s) with unknown file types."))
      # bedgraphs_filetypes = bedgraphs_filetypes[-unknw_filetypes]
      # files = files[-unknw_filetypes]
    }

    if(length(files) == 0){
      stop("No supported file formats found!")
    }
  }else if(file_format == "bedGraph"){
    bedgraphs_filetypes = rep('bedGraph', length(files))
  }else if(file_format == "coverage"){
    bedgraphs_filetypes = rep('coverage', length(files))
  }else{
    stop("Unknown file format!\n file_format can only be bedGraph or coverage")
  }

  #Get number of cores. If user deosnt provide any, all-1 cores
  if(is.null(n_cores)){
    n_cores = parallel::detectCores() - 1
    message(paste0("#-Using ", n_cores, " cores of availabe ", parallel::detectCores() , " cores."))
  }else{
    n_cores = as.numeric(as.character(n_cores))
  }

  #Set colData
  if(is.null(colData)){
    colData = data.frame(row.names = unlist(data.table::tstrsplit(x = basename(files), split = '\\.', keep = 1)), stringsAsFactors = FALSE)
  }else{
    if(length(files) != nrow(colData)){
      stop("Number of samples in colData does not match the number of input files.")
    }
  }

  #Read bedGraphs
  ##If mixed filetypes are provided, process them as bedGraphs and dont generate coverage matrix.
  if(length(unique(bedgraphs_filetypes)) > 1){
    message("Mixed file formats found. All files are processed as bedGraphs.\nNo coverage matrices will be generated!", appendLF = TRUE)
    final_file_type = "bedGraph"
  }else if(unique(bedgraphs_filetypes) == 'bedGraph'){
    final_file_type = "bedGraph"
  }else{
    final_file_type = "coverage"
  }

  #loci = "inst/extdata/mm10_CpG.tsv.gz"
  if(!is.null(loci)){
    tictoc::tic(paste0("#-Reading CpG sites .."))
    cpg_sites = data.table::fread(input = loci, showProgress = FALSE)
    colnames(cpg_sites)[1:2] = c("contig", "start")
    cpg_sites[, id := paste0(contig, ":", start)]
    data.table::setkey(x = cpg_sites, id)
    if(nrow(cpg_sites[duplicated(id)]) > 0){
      stop("Duplicated loci in the provided known CpGs", call. = FALSE)
    }
    cpg_sites = cpg_sites[,.(id)]
    tictoc::toc()
  }else{
    cpg_sites = NULL
  }

  tictoc::tic("#-Creating methylation/coverage matrices")
  message(paste0('#-Processing ', length(files), ' ', final_file_type, ' files..'))
  if(vectorize){
    #NOTE: mclapply and nThreads from data.table are thread unsafe. fread will be run with default setting.
    bm_dat = .read_bismark_bedgraph_vect(bdg = files, file_type = final_file_type, cpg_loci = cpg_sites,
                                        parallel_threads = n_cores, shift_start = shift_start)
    methylation_matrix = bm_dat[[1]]
    coverage_matrix = bm_dat[[2]]
    colnames(methylation_matrix) = colnames(coverage_matrix) = rownames(colData)
  }else{
    #For loop (single sample at a time)
    #Intialize both matrices
    if(!is.null(loci)){
      coverage_matrix = methylation_matrix = data.frame(row.names = as.character(cpg_sites$id))
    }

    for(i in seq_along(files)){
      #message(basename(bedgraphs[i]))
      bm_dat = .read_bismark_bedgraph(bdg = files[i], file_type = final_file_type, cpg_loci = cpg_sites, read_threads = n_cores, shift_start = shift_start)
      if(!is.null(loci)){
        methylation_matrix = cbind(methylation_matrix,
                                   data.table:::as.matrix.data.table(x = bm_dat[[1]], rownames = "id"))
        coverage_matrix = cbind(coverage_matrix,
                                data.table:::as.matrix.data.table(x = bm_dat[[2]], rownames = "id"))
      }else{
        if(i == 1){
          methylation_matrix = bm_dat[[1]]
          coverage_matrix = bm_dat[[2]]
        }else{
          methylation_matrix = merge(methylation_matrix, bm_dat[[1]])
          coverage_matrix = merge(coverage_matrix, bm_dat[[2]])
        }
      }
      colnames(methylation_matrix)[ncol(methylation_matrix)] = colnames(coverage_matrix)[ncol(methylation_matrix)] = rownames(colData)[i]
    }
  }

  #Sanity check
  if(!is.null(loci)){
    if(!identical(x = rownames(methylation_matrix), y = cpg_sites$id)){
      stop("Something went wrong!\nCpG loci are not ordered.")
    }
  }else{
    loci = data.table::data.table(loci = rownames(methylation_matrix))
  }

  message("#-All done!")
  tictoc::toc()


  if(h5){
    se = methrix(SE = SummarizedExperiment::SummarizedExperiment(assays = list(methylation_matrix = DelayedArray::DelayedArray(methylation_matrix),
                                                                  coverage_matrix = DelayedArray::DelayedArray(coverage_matrix))),
                                                    CpGs = nrow(methylation_matrix), samples = ncol(methylation_matrix), h5 = h5)
    if(!is.null(h5_dir)){
      HDF5Array::saveHDF5SummarizedExperiment(x = se, dir = h5_dir, replace = TRUE)
    }
  }else{
    se = methrix(SE = SummarizedExperiment::SummarizedExperiment(assays = list(methylation_matrix = methylation_matrix,
                                                                               coverage_matrix = DelayedArray::DelayedArray(coverage_matrix))),
                 CpGs = nrow(methylation_matrix), samples = ncol(methylation_matrix), h5 = h5)
  }


  se
}


.guess_bismark_file_type = function(bdg = NULL){
  bdg_test = data.table::fread(file = bdg, header = FALSE, nrows = 10)
  if(ncol(bdg_test) == 4){
    return("bedGraph")
  }else if(ncol(bdg_test) == 6){
    return("coverage")
  }else{
    return(NA)
  }
}


.read_bismark_bedgraph = function(bdg = NULL, file_type = NULL, cpg_loci = NULL, read_threads = 1, shift_start = FALSE){

  cov_matrix = meth_matrix = NULL

  if(file_type == "bedGraph"){
    bdg = data.table::fread(file = bdg, header = FALSE,
                            col.names = c('contig', 'start', 'end', 'meth'), sep = "\t")
  }else{
    bdg = data.table::fread(file = bdg, header = FALSE,
                            col.names = c('contig', 'start', 'end', 'meth', 'n_meth_count', 'n_unmeth_count'), sep = "\t")

    #Since coverage files are 1-based, shift start & end loci previous base (0-based)
    if(shift_start){
      bdg[, start := as.numeric(as.character(start)) - 1]
      bdg[, end := as.numeric(as.character(end)) - 1]
    }
    bdg[, coverage := as.numeric(as.character(n_meth_count))+as.numeric(as.character(n_unmeth_count))]
    bdg
  }

  #ID for each CpG
  bdg[, id := paste0(contig, ":", start)]
  data.table::setkey(x = bdg, "id")

  #Add CpG annotations
  if(!is.null(cpg_loci)){
    bdg = merge(cpg_loci[, .(id)], bdg, by = "id", all.x = TRUE)
  }
  #Order by id
  data.table::setorder(x = bdg, id)

  if(file_type == "coverage"){
    cov_matrix = bdg[,.(id, coverage)]
  }else{
    cov_matrix = data.table::data.table(id = meth_matrix$id, coverage = 0, key = "id")
  }

  return(list(methylation_matrix = bdg[,.(id, meth)],
              coverage_matrix = cov_matrix))
}


.read_bismark_bedgraph_vect = function(bdg, file_type = NULL, cpg_loci = NULL, shift_start = FALSE, parallel_threads = 1){

  if(file_type == "bedGraph"){
    bdg_list = parallel::mclapply(X = bdg, function(x){
      data.table::fread(file = bdg, header = FALSE,
                              col.names = c('contig', 'start', 'end', 'meth'), sep = "\t",
                        colClasses = c("character", "integer", "integer", "numeric"))
    }, mc.cores = parallel_threads)
  }else{
    bdg_list = parallel::mclapply(X = bdg, function(x){
      b = data.table::fread(file = x, header = FALSE,
                        col.names = c('contig', 'start', 'end', 'meth', 'n_meth_count', 'n_unmeth_count'),
                        sep = "\t", colClasses = c("character", "integer", "integer", "numeric", "integer", "integer"))
      #Since coverage files are 1-based, shift start & end loci to previous base (0-based)
      if(shift_start){
        b[, start := start - 1]
        b[, end := end - 1]
      }
      b[, coverage := n_meth_count+n_unmeth_count]
      b
    },  mc.cores = parallel_threads)
  }

  names(bdg_list) = unlist(data.table::tstrsplit(x = basename(bdg), split = '\\.', keep = 1))
  bdg_list = data.table::rbindlist(l = bdg_list, idcol = "sample", use.names = TRUE, fill = TRUE)
  #ID for each CpG
  bdg_list[, id := paste0(contig, ":", start)]
  #Un-comment below for setting keys (Will take a time )
  #data.table::setkey(x = bdg_list, "id")

  if(file_type == 'bedGraph'){
    meth_matrix = data.table::dcast(data = bdg_list, id ~ sample, value.var = 'meth', fill = NA)
  }else{
    meth_matrix = data.table::dcast(data = bdg_list, id ~ sample, value.var = 'meth', fill = NA)
    cov_matrix = data.table::dcast(data = bdg_list, id ~ sample, value.var = 'coverage', fill = 0)

    if(nrow(meth_matrix) != nrow(cov_matrix)){
      stop("Something went wrong!\nNumber of CpG loci in methylation and coverage matrix do not match.", call. = TRUE)
    }
  }

  #Add CpG annotations
  if(is.null(cpg_loci)){
    meth_matrix = data.table:::as.matrix.data.table(x = meth_matrix, rownames = 'id')
    cov_matrix = data.table:::as.matrix.data.table(x = cov_matrix, rownames = 'id')
  }else{
    meth_matrix = merge(cpg_loci, meth_matrix, by = "id", all.x = TRUE)
    meth_matrix = data.table:::as.matrix.data.table(x = meth_matrix, rownames = 'id')
    cov_matrix = merge(cpg_loci, cov_matrix, by = "id", all.x = TRUE)
    cov_matrix = data.table:::as.matrix.data.table(x = cov_matrix, rownames = 'id')
  }

  return(list(methylation_matrix = meth_matrix, coverage_matrix = cov_matrix))
}
