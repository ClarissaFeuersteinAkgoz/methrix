#' Versatile BedGraph reader.
#' @details Reads bismark coverage files and generates methylation and coverage matrices. Optionally arrays can be serialized as on-disk HDFS5 arrays.
#' @param files bedgraphs or coverage files generated by Bismark. Default NULL
#' @param pipeline Default NULL. Can be "Bismark" or "MethylDeckal".
#' @param loci NULL (Default) or a file with  "chromsome" and "start" position. If provided matrix will be generated for these CpGs
#' @param colData An optional DataFrame describing the samples. Row names, if present, become the column names of the matrix. If NULL, then a DataFrame will be created with basename of files used as the row names.
#' @param file_format are input files bedgraph or coverage files. Default 'auto' predicts.
#' @param vectorize Default TRUE. If FALSE uses for loop (much slower but consumes lesser memory)
#' @param n_cores number of cores to use. Default NULL. Uses available cores - 1
#' @param shift_start Default FALSE. If coordinates are one-based, set this is to TRUE, and start positions will be shifted to its previous base (0-based).
#' @param h5 Should the coverage and methylation matrices be stored as "HDF5Array"
#' @param h5_dir directory to store H5 based object
#' @export
#' @import data.table
#' @import parallel
#' @import SummarizedExperiment
#'
read_bedgraphs = function(files = NULL, pipeline = NULL, chr_idx = NULL, start_idx = NULL, end_idx = NULL, beta_idx = NULL,
                          M_idx = NULL, U_idx = NULL, strand_idx = NULL, cov_idx = NULL, coldata = NULL, h5 = FALSE, h5_dir = NULL){

  if(is.null(files)){
    stop("Missing input files.", call. = FALSE)
  }

  #Set colData
  if(is.null(coldata)){
    coldata = data.frame(row.names = unlist(data.table::tstrsplit(x = basename(files), split = '\\.', keep = 1)),
                         stringsAsFactors = FALSE)
  }else{
    if(length(files) != nrow(coldata)){
      stop("Number of samples in coldata does not match the number of input files.")
    }
  }

  #Final aim is to bring input data to the following order:
  ##chr start end beta cov starnd <rest..>
  if(is.null(pipeline)){
    col_idx = .parse_source_idx(chr = chr_idx, start = start_idx, end = end_idx, beta = beta_idx,
                                cov = cov_idx, strand = strand_idx, n_meth = M_idx, n_unmeth = U_idx)
    col_idx$col_classes = NULL
  }else{
    pipeline = match.arg(arg = pipeline, choices = c("Bismark_cov", "MethylDackel"))
    message(paste0("Using ", pipeline, " as a preset.."))
    col_idx = .get_source_idx()
  }

  #x = .read_bdg(bdg = files[1], )
  bdgs = lapply(files, .read_bdg, col_list = col_idx)
  names(bdgs) = rownames(coldata)
  bdgs = data.table::rbindlist(l = bdgs, idcol = "sample")
  beta_mat = data.table::dcast(bdgs, chr + start ~ sample, value.var = "beta")
  cov_mat = data.table::dcast(bdgs, chr + start ~ sample, value.var = "cov", fill = 0)

  if(nrow(beta_mat) != nrow(cov_mat)){
    stop("Discrepancies in dimensions of coverage and beta value matrices.")
  }

  if(h5){
    se = methrix(SE = SummarizedExperiment::SummarizedExperiment(assays = list(methylation_matrix = DelayedArray::DelayedArray(beta_mat[,3:ncol(beta_mat)]),
                                                                               coverage_matrix = DelayedArray::DelayedArray(cov_mat[,3:ncol(cov_mat)]))),
                 CpGs = nrow(beta_mat), samples = nrow(coldata), h5 = as.logical(h5))
    if(!is.null(h5_dir)){
      HDF5Array::saveHDF5SummarizedExperiment(x = se@SE, dir = h5_dir, replace = TRUE)
    }
  }else{
    se = methrix(SE = SummarizedExperiment::SummarizedExperiment(assays = list(methylation_matrix = beta_mat[,3:ncol(beta_mat)],
                                                                               coverage_matrix = cov_mat[,3:ncol(cov_mat)])),
                 CpGs = nrow(beta_mat), samples = nrow(coldata), h5 = as.logical(h5))
  }

  return(se)
}


#Bismark and methyldackel have same output formal
.get_source_idx = function(){
  return(list(col_idx = c(chr = 1, start = 2, end = 3, beta = 4, M = 5, U = 6),
              col_classes = c("character", "integer", "integer", "numeric", "integer", "integer"),
              fix_missing = c("cov := M+U", "strand := '.'")))
}

#Custom indices
.parse_source_idx = function(chr = NULL, start = NULL, end = NULL, strand = NULL,
                             beta = NULL, n_meth = NULL, n_unmeth = NULL, cov = NULL, beta_fract = FALSE){

  #mandatory chr and start field
  if(is.null(chr) | is.null(start)){
    stop("missing chromosome/start indices\nUse pipeline argument if the files are from Bismark or MethyDeckal", call. = FALSE)
  }

  #See if any indices are duplicated
  if(length(which(duplicated(c(chr, start, end, strand, beta, n_meth, n_unmeth, cov)))) > 0){
    stop("Duplicated indices.", call. = FALSE)
  }

  #Check maximum betavalues (Can be 1 or 100)
  if(beta_fract){
    cov_scale = 1
  }else{
    cov_scale = 100
  }

  if(is.null(strand)){
    fix_missing = "strand := '*'"
  }

  #If beta and cov are missing
  if(all(is.null(beta), is.null(cov))){
    if(is.null(n_meth) | is.null(n_unmeth)){
      stop("Missing beta or coverage values.\nU and M are not available either!", call. = FALSE)
    }else{
      message("Missing beta and coverage info.\nEstimating them from M and U values.")
      return(list(col_idx = c(chr = chr, start = start, end = end, strand = strand,
                              beta = beta, M = n_meth, U = n_unmeth, cov = cov),
                  fix_missing = c(fix_missing, "cov := M+U", "beta := M/(M+U)")))
    }
  }else if(is.null(beta) & !is.null(cov)){ #If anyone of them is present (case-1: coverage available, estimate beta)
    if(all(is.null(n_meth), is.null(n_unmeth))){
      stop("Missing beta values but coverage info available.\nEither U or M are required for estimating beta values!", call. = FALSE)
    }else if(all(!is.null(n_meth), !is.null(n_unmeth))){
      message("Estimating beta values from M and U..")
      return(list(col_idx = c(chr = chr, start = start, end = end, strand = strand,
                              beta = beta, M = n_meth, U = n_unmeth, cov = cov),
                  fix_missing = c(fix_missing, "beta := M/(M+U")))
    }else if(!is.null(n_meth)){ #M available
      message("Estimating beta values from M and coverage..")
      return(list(col_idx = c(chr = chr, start = start, end = end, strand = strand,
                              beta = beta, M = n_meth, U = n_unmeth, cov = cov),
                  fix_missing = c(fix_missing, "beta := M/cov")))
    }else if(!is.null(n_unmeth)){ #U available
      message("Estimating beta values from U and coverage..")
      return(list(col_idx = c(chr = chr, start = start, end = end, strand = strand,
                              beta = beta, M = n_meth, U = n_unmeth, cov = cov),
                  fix_missing = c(fix_missing, paste0("beta := 1- (U/cov)"))))
    }
  } else if(!is.null(beta) & is.null(cov)){ #If anyone of them is present (case-2: beta available, estimate coverage)
    if(all(is.null(n_meth), is.null(n_unmeth))){
      stop("Missing coverage info but beta values are available.\nU and M are required for estimating coverage values!", call. = FALSE)
    }else{
      message("Estimating coverage from M and U..")
      return(list(col_idx = c(chr = chr, start = start, end = end, strand = strand,
                              beta = beta, M = n_meth, U = n_unmeth, cov = cov),
                  fix_missing = c(fix_missing, "cov := M+U")))
    }
  }
}

.read_bdg = function(bdg, col_list = NULL){

  bdg_dat = data.table::fread(file = bdg, sep = "\t", colClasses = col_list$col_classes)
  colnames(bdg_dat)[col_list$col_idx] = names(col_list$col_idx)

  if(!is.null(col_list$fix_missing)){
    for(cmd in col_list$fix_missing){
      bdg_dat[,eval(parse(text=cmd))]
    }
  }

  bdg_dat = bdg_dat[,.(chr, start, beta, cov, strand)]
  return(bdg_dat)
}
